---
title: 领域驱动设计
date: 2022-09-15 18:16:09
tags:
---
## 领域驱动设计

>**领域驱动设计(DDD)** 是一种通过将实现连接到持续进化的模型来满足复杂需求的软件开发方法. 领域驱动设计的前提是:
>* 把项目的主要重点放在核心领域和领域逻辑上
>* 把复杂的设计放在领域模型上
>* 发起技术专家和领域专家之间的创造性协作,以迭代方式完善解决特定领域问题的概念模型

### 分层
ABP框架遵循DDD原则和模式去实现分层应用程序模型,该模型由四个基本层组成:

* **表示层:** 为用户提供接口. 使用应用层实现与用户交互.
* **应用层:** 表示层与领域层的中介,编排业务对象执行特定的应用程序任务. 使用应用程序逻辑实现用例.
* **领域层:** 包含业务对象以及业务规则. 是应用程序的核心.
* **基础设施层:** 提供通用的技术功能,支持更高的层,主要使用第三方类库.

### 领域层

#### 实体

实体通常映射到关系型数据库的表中.
实体都继承自Entity<TKey>类,如下所示:
~~~ C#
public class Book : Entity<Guid>
{
    public string Name { get; set; }
    public float Price { get; set; }
    protected Book()
    {
    }
    public Book(Guid id)
     : base(id)
    {
    }
}
~~~
>如果你不想继承基类`Entity<TKey>`,也可以直接实现`IEntity<TKey>`接口

`Entity<TKey>`类只是用给定的主 键类型定义了一个Id属性,在上面的示例中是Guid类型.可以是其他类型如`string, int, long`或其他你需要的类型.

**Guid主键的实体**
* 创建一个构造函数,获取ID作为参数传递给基类.如果没有为`GUID Id`赋值,ABP框架会在保存时设置它,但是在将实体保存到数据库之前最好在实体上有一个有效的`Id`.
* 如果使用带参数的构造函数创建实体,那么还要创建一个 `private` 或 `protected` 构造函数. 当数据库提供程序从数据库读取你的实体时(反序列化时)将使用它.
* 不要使用 `Guid.NewGuid()` 来设置`Id`! 在创建实体的代码中使用`IGuidGenerator`服务 传递Id参数. `IGuidGenerator`经过优化可以产生连续的`GUID`.这对于关系数据库中的聚集索引非常重要.

**具有复合键的实体**
有些实体可能需要 **复合键** .在这种情况下,可以从非泛型`Entity`类派生实体.如:
~~~C#
public class UserRole : Entity
{
    public Guid UserId { get; set; }

    public Guid RoleId { get; set; }
    
    public DateTime CreationTime { get; set; }

    public UserRole()
    {
            
    }
    
    public override object[] GetKeys()
    {
        return new object[] { UserId, RoleId };
    }
}
~~~
上面的例子中,复合键由`UserId和RoleId`组成.在关系数据库中,它是相关表的复合主键. 具有复合键的实体应当实现上面代码中所示的`GetKeys()`方法.
>需要注意,复合主键实体不可以使用 `IRepository<TEntity, TKey> `接口,因为它需要一个唯一的`Id`属性. 但你可以使用`IRepository<TEntity>`.

#### 聚合根
`AggregateRoot<TKey>`类继承自`Entity<TKey>`类,所以默认有`Id`这个属性
>值得注意的是 ABP 会默认为聚合根创建仓储,当然,ABP也可以为所有的实体创建仓储

**聚合根例子**
这是一个具有子实体集合的聚合根例子:
~~~C#
public class Order : AggregateRoot<Guid>
{
    public virtual string ReferenceNo { get; protected set; }

    public virtual int TotalItemCount { get; protected set; }

    public virtual DateTime CreationTime { get; protected set; }

    public virtual List<OrderLine> OrderLines { get; protected set; }

    protected Order()
    {

    }

    public Order(Guid id, string referenceNo)
    {
        Check.NotNull(referenceNo, nameof(referenceNo));
        
        Id = id;
        ReferenceNo = referenceNo;
        
        OrderLines = new List<OrderLine>();
    }

    public void AddProduct(Guid productId, int count)
    {
        if (count <= 0)
        {
            throw new ArgumentException(
                "You can not add zero or negative count of products!",
                nameof(count)
            );
        }

        var existingLine = OrderLines.FirstOrDefault(ol => ol.ProductId == productId);

        if (existingLine == null)
        {
            OrderLines.Add(new OrderLine(this.Id, productId, count));
        }
        else
        {
            existingLine.ChangeCount(existingLine.Count + count);
        }

        TotalItemCount += count;
    }
}

public class OrderLine : Entity
{
    public virtual Guid OrderId { get; protected set; }

    public virtual Guid ProductId { get; protected set; }

    public virtual int Count { get; protected set; }

    protected OrderLine()
    {

    }

    internal OrderLine(Guid orderId, Guid productId, int count)
    {
        OrderId = orderId;
        ProductId = productId;
        Count = count;
    }

    internal void ChangeCount(int newCount)
    {
        Count = newCount;
    }

    public override object[] GetKeys()
    {
        return new Object[] {OrderId, ProductId};
    }
}

~~~

>如果你不想你的聚合根继承`AggregateRoot<TKey>`类,你可以直接实现`IAggregateRoot<TKey>`接口

`Order`是一个具有`Guid`类型`Id`属性的 **聚合根**.它有一个`OrderLine`实体集合.`OrderLine`是一个具有组合键(`OrderId和 ProductId`)的实体.

虽然这个示例可能无法实现聚合根的所有最佳实践,但它仍然遵循良好的实践:

* `Order`有一个公共的构造函数,它需要 minimal requirements 来构造一个"订单"实例.因此,在没有`Id`和`referenceNo`的时候是无法创建订单的.`protected/private`的构造函数只有从数据库读取对象时 **反序列化** 才需要.
* `OrderLine`的构造函数是`internal`的,所以它只能由领域层来创建.在`Order.AddProduct`这个方法的内部被使用.
* `Order.AddProduct`实现了业务规则将商品添加到订单中
所有属性都有`protected的set`.这是为了防止实体在实体外部任意改变.因此,在没有向订单中添加新产品的情况下设置 `TotalItemCount`将是危险的.它的值由`AddProduct`方法维护.


